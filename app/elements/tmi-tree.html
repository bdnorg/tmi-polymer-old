<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="tmi-tab">
  <style>
    :host {display: block;}
    :host([pointer]) {background-color: pink;}
    .ind {margin-left: 1.5em;
    .clip {white-space: nowrap; overflow: hidden;}
    }
  </style>
  <template>
    <div>
      <input type="checkbox" name="tabCheck" value="{{tab.id}}">
      <span>
         <iron-icon icon="receipt"
                    style="height: 16px; width: 16px;"></iron-icon>
      </span>
      <span>{{tab.title}}</span> - <span>{{tab.id}}</span>
    </div>
  </template>
</dom-module>
<script>
  (function () {
    Polymer({
      is: 'tmi-tab',
      properties: {
        tab: {
          type: Object,
        },
        roott: {
          type: Object,
        },
        winid: {
          readOnly: true,
          reflectToAttribute: true,
          type: String,
        },
      },
      getWinId: function(){
        return this.tab.windowId;
      },
      isTab: true,
      tab: this.tab
    });
  })();
</script>

<dom-module id="tmi-win-display">
  <template>
    [<iron-icon icon="receipt"
                style="height: 16px; width: 16px;"></iron-icon>
     <span>[[win.tabs.0.title]]</span>]
  </template>
</dom-module>
<script>
  (function () {
    Polymer({
      is: 'tmi-win-display',
      properties: {
        win: {
          type: Object,
        },
      },
      ready: function() {
      },
    });
  })();
</script>

<!--
    <core-tooltip label="I'm a tooltip" position="bottom ">
      <div tip>
        <tmi-win-display id="{{win.id}}" win="{{win}}"></tmi-win-display>
      </div>
    </core-tooltip>

      <div class="clip {{ {pointer: win.id == pointer} | tokenList}}">
      </div>
-->

<dom-module id="tmi-node">
  <template>
    <span>{{mark}}</span>
  </template>
</dom-module>
<script>
  (function () {
    Polymer({
      is: 'tmi-node',
      properties: {
        mark: {
          type: String,
        }
      }
    });
  })();
</script>

<dom-module id="tmi-window">
  <style>
   .tabBlock{
     margin-left: 2em;
     white-space: nowrap;
     overflow: hidden;
     background-color: white;
   }
   .ind {margin-left: 2em;}
   .clip {white-space: nowrap; overflow: hidden;}
   :host {
     display: block;
     border: solid white 1px;
   }
   :host([pointer]) {
     background-color: pink;
     border: solid red 1px;
   }
   .collapse-content {
     padding: 5px;
     border: 1px solid #dedede;
  }
  </style>
  <template>
<!--
    <div class="clip {{ {pointer: win.id == pointer} | tokenList}}">
-->
    <div class="clip"> <div id="pnode">
      <span>{{mark}}</span>
      <span on-click="toggle">
        <iron-icon icon="expand-more"
                   style="height: 16px; width: 16px;"></iron-icon>
      </span>
      <input type="checkbox" name="winCheck"
             value="{{node.id}}">
      (<span>{{win.tabs.length}}</span>)
        <span>{{node.name}}</span>
        <tmi-win-display win="{{win}}"></tmi-win-display>
        - <span>{{node.id}}</span>
    </div></div>
    <content></content>

<!--
    <iron-collapse id="collapse" class="">
      <div class="collapse-content tabBlock ind clip">
        <template is="dom-repeat" items="{{win.tabs}}" as="tab">
          <tmi-tab tab="{{tab}}" id="{{roott.makeId(tab.id)}}"
                   winid$="{{roott.makeId(tab.windowId)}}"
                   tabid="{{tab.id}}"
                   roott="{{roott}}"
                   class="node"></tmi-tab>
        </template>
      </div>
    </iron-collapse>
-->

  </template>
</dom-module>
<script>
  (function () {
    Polymer({
      is: 'tmi-window',
      properties: {
        node: {
          type: Object,
        },
        win: {
          type: Object,
        },
        roott: {
          type: Object,
        },
        pointer: {
          type: Boolean,
          notify: true,
        },
        mark: {
          type: String,
        },
      },
      ready: function() {
      },
//      collapse: function(event, detail, sender) {
      toggle: function() {
        if (this.roott.getPointerWin().id === this.id) {
          this.roott.setPointerId(this.id);
        }
//        this.$.collapse.toggle();
        this.querySelector('iron-collapse').toggle();
      },
      isTab: false,
      win: this.win,
    });
  })();
</script>

<dom-module id="tmi-tree">
  <style>
    .pointer {background-color: pink;}
    .ind {margin-left: 1.5em;}
    .clip {white-space: nowrap; overflow: hidden;}
  </style>
  <template>
    <div class="ind">
    <iron-collapse id="collapseGroup" class="" opened="true">
      <template is="dom-repeat" items="{{nodes}}" as="node">
        <tmi-window node="{{node}}" id="{{node.id}}"
                    win="{{node.win}}"
                    class="node" roott="{{roott}}"
                    pointer$="{{node.pointer}}">


          <iron-collapse id="collapse" class="">
            <div class="collapse-content tabBlock ind clip">
              <template is="dom-repeat" items="{{node.win.tabs}}" as="tab"
                        filter="{{tabFilter(searchstr)}}">
                <tmi-tab tab="{{tab}}" id="{{makeId(tab.id)}}"
                         winid$="{{makeId(tab.windowId)}}"
                         tabid="{{tab.id}}"
                         roott="{{roott}}"
                         class="node"></tmi-tab>
              </template>
            </div>
          </iron-collapse>

        </tmi-window>
      </template>
    </iron-collapse>
    </div>
    <tmi-browser id="browser"
                 new-wins="{{newWins}}"></tmi-browser>
  </template>
</dom-module>
  <script>
    (function () {
      'use strict';
      var polymerObj = {
//      Polymer({
        is: 'tmi-tree',
        properties: {
          searchstr: {
            type: String,
            notify: true,
          }
        },
        observers: [
          '_syncWins(newWins.*)',
          'setPointerOnSearch(searchstr)',
        ],
        ready: function() {
          this._initData();
          this.roott = this;
          this.$.browser.updateWins();
        },
        created: function() {},
        attached: function() {},
        nodes: [],

        // Tree helpers
        makeId: function(id){return 'id-' + id;},
        // sync Nodes
        _initData:function() {
          this.nodes = tmi.bg.tree.getNodes();
//          this.set('nodes', tmi.bg.tree.getNodes());
        },
        _syncWins: function(newWinsChange) {
          var fullRefresh = true;
//TODO    check session id hasn't changed (and can't trust winIds)
          console.log('sync newWins: ', newWinsChange);
          console.log('sync this.newWins: ', this.newWins);
          if (! this.nodes) {this.nodes = []; }
//          var nodes = this.nodes;
//          var nodes = this.nodes ? this.nodes : [];
          var i = this.nodes.length;
          while(i--) {   //reverse loop over this.nodes
            var node = this.nodes[i];
            if (this.newWins.hasOwnProperty(node.winId)) { //changed
              if (this.newWins[node.winId]) { //not deleted
                var updatedWin = this.newWins[node.winId];
//                this.set('nodes.'+i+'.pointer', updatedWin.focused);
                this.set('nodes.'+i+'.win', updatedWin);
//              this.storeWindow();
              } else { //deleted
                //delete node
                this.splice('nodes', i, 1);
//                this.handleDeleteNode(node);
//              this.storeWindow();
              }
              delete this.newWins[node.winId];
           } else {
              if (fullRefresh) {  //delete node because not in newWinsChange
                this.splice('nodes', i, 1);
              }
            }
          }

          // everything left is a new window
          var keys = Object.keys(this.newWins);
          for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            var win = this.newWins[key];
            if(win) {
              this.push('nodes', {id: this.makeId(win.id), winId: win.id, win: win});
//              this.storeWindow();
            } else {
              console.log('This should not happen (failed to delete win): ', key);
            }
          }
          tmi.bg.tree.setNodes(this.nodes);
          this.setPointerToCurrentWin();
        },

        tabFilter: function(string) {
          if (!string) {
            // set filter to null to disable filtering
            return null;
          } else {
            // return a filter function for the current search string
            string = string.toLowerCase();
            return function(tab) {
              var title = tab.title.toLowerCase();
              var url = tab.url.toLowerCase();
              return (title.indexOf(string) !== -1 ||
                url.indexOf(string) !== -1);
            };
          }
        },


        //Nodes
        treeQuery: function(query){
//          var el = this.shadowRoot.querySelector('::shadow .iron-collapse-opened ' + query + ', ' + query);
          return this.$$('tmi-window .iron-collapse-opened ' + query + ', ' + query);
//          var el = this.shadowRoot.querySelector('tmi-window .iron-collapse-opened ' + query + ', ' + query);
//          return el;
        },
        treeQueryAll: function(query){
          var els = this.shadowRoot.querySelectorAll('tmi-window .iron-collapse-opened ' + query + ', ' + query);
          return els;
        },
        getNode: function(id){
          return this.treeQuery('#' + id);
        },
        getFirstEl: function(){
          return this.treeQuery('tmi-window');
        },
        getVisibleEls: function(){
//          return this.shadowRoot.querySelectorAll('.node, ::shadow .iron-collapse-opened .node');
          return this.shadowRoot.querySelectorAll('tmi-window, tmi-window .iron-collapse-opened tmi-tab');
        },


        //Pointer
        setPointer: function(el){
          var oldEl = this.getPointer();
          if (! el) {
            el = this.getFirstEl();
          }
          return this.attributeFollows('pointer', el, oldEl);

//          if (oldEl) {
//            this.getPointer().removeAttribute('pointer');
//          }
//          if (el) {
//            el.setAttribute('pointer', '');
//          } else {
//            this.getFirstEl().setAttribute('pointer', '');
//          }
        },
        setPointerId: function(id){
          var newEl = this.getNode(id);
          if (newEl) {
            this.setPointer(newEl);
          }
        },
        setPointerToCurrentWin: function() {
          var self = this;
          this.async(function(){
            tmi.chrome.windows.getCurrent(function(win){
              self.setPointerId(self.makeId(win.id));
            });
          });
        },
        getPointer: function(){
          var pointer = this.treeQuery('.node[pointer]');
          if (!pointer) {
            pointer = this.getFirstEl();
            pointer.setAttribute('pointer', '');
          }
          return pointer;
        },
        getPointerWin: function(){
          var el = this.getPointer();
          if (el.tagName === 'TMI-TAB'){
            return this.getNode(this.makeId(el.getWinId()));
          }
          return el;
        },
        getPointerIndex: function(elList){
          for (var i = 0; i < elList.length; i++) {
            if (elList[i].hasAttribute('pointer')){
              return i;
            }
          }
          return 0;
        },

//TODO: consider 1) el ids (eg "id-1234") 2) closed windows.
        branchOnNodeType: function(funcs){
          var self = this;
          return function(){
            var pointer = self.getPointer();
//            var type = pointer.getType();
//            funcs[type](pointer[type].id);
            if (pointer.tab) {
              funcs.tab(pointer.tab.id);
            } else {
              funcs.win(pointer.win.id);
            }
          };
        },

        //Tree movement
        down: function(){
          var elList = this.getVisibleEls();
          var i = this.getPointerIndex(elList);
          elList[i].removeAttribute('pointer');
//          elList[i+1].setAttribute('pointer', '');
          elList[(i+1 + elList.length) % elList.length].setAttribute('pointer', '');
        },
        up: function(){
          var elList = this.getVisibleEls();
          var i = this.getPointerIndex(elList);
          elList[i].removeAttribute('pointer');
//          elList[i-1].setAttribute('pointer', '');
          elList[(i-1 + elList.length) % elList.length].setAttribute('pointer', '');
        },
        right: function(){
          this.getPointerWin().toggle();
        },
        left: function(){
          this.getPointerWin().toggle();
        },
        downTen: function(){},
        upTen: function(){},
        moveTop: function(){},
        moveBottom: function(){},

        //nav wintabs
//        browser.focusWin: function(win){},
//        browser.focusTab: function(tab){},
        pin: function(){
          var elList = this.getVisibleEls();
          var i = this.getPointerIndex(elList);
          var moved = this.nodes[i];
          this.splice('nodes', i, 1);
          this.unshift('nodes', moved);
        },
        hideAll: function(){
          var wins = this.treeQueryAll('tmi-window iron-collapse');
          for (var i=0; i < wins.length; i++) {
            wins[i].hide();
          }
          this.setPointerToCurrentWin();
        },
        showAll: function(){
          var wins = this.treeQueryAll('tmi-window iron-collapse');
          for (var i=0; i < wins.length; i++) {
            wins[i].show();
          }
        },
        searchMode: function(e){
          this.showAll();
          console.log('searching');
          e.preventDefault();
//          this.treeQuery('input').focus();
          document.querySelector('#searchBox').focus();
        },
        setPointerOnSearch: function(searchstr){
          this.async( function(){
            var firstTab = this.treeQuery('tmi-tab');
            this.setPointer(firstTab);
          });
        },
        getNodeFromMark: function(mark){
          var elList = this.getVisibleEls();
          var i = elList.length;
          while(i--) {   //reverse loop
            var node = elList[i];
            if (node.mark === mark) {
              return node;
            }
          }
          return null;
        },
        goMark: function(){
//          var key = getOneKey();
//          var key = 'z';
//          this.setPointer(getNodeFromMark(mark));
        },
        mark: function(){
//          var key = getOneKey();
          var key = 'z';
          var oldMarkNode = this.getNodeFromMark();
          if (oldMarkNode){ oldMarkNode.mark = ''; }
          this.getPointer().mark = key;
        },

        //manage wintabs
//        putAfterTab: function(tab){},
//        putEndOfWin: function(win){},
        putNew: function(){},
        name: function(){},
        toSave: function(){},
        close: function(){},
//        delete: function(){},

        //Freezing
//        makeFreezer: function(closed){},
//        browser.bmFreeze: function(win){},
//        browser.freezeAll: function(key){},
//        browser.freezeTab: function(tab){},


        //Popup manage
//        break: function(){},
        quit: function(){},
        refresh: function(){},
        injectPointer: function(func) {
          return function(){ func(this.getPointer()); };
        },
        injectPointerWin: function(func) {
          return function(){ func(this.getPointerWin()); };
        },


      }; // end polymerObj {}
//      _.bindAll(polymerObj);
//      polymerObj.polymerObjKeys = Object.keys(polymerObj);
      polymerObj.methodNames = _.select( Object.keys(polymerObj),
        function(n){ return _.isFunction(polymerObj[n]); });
      Polymer(polymerObj);
//      }); //end Polymer()
    })();
  </script>


